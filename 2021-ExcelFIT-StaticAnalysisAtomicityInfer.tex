%===============================================================================
% (c) Dominik Harmim <xharmi00@stud.fit.vutbr.cz>
%===============================================================================


\documentclass{ExcelAtFIT}


\usepackage{bm}
\usepackage{amsthm}
\usepackage{wrapfig}
\usepackage[normalem]{ulem}

% Solves first/last row of the paragraph on the previous/next page.
\clubpenalty=10000
\widowpenalty=10000

\interfootnotelinepenalty=10000 % do not separate footnotes to multiple pages

% Example theorem.
\theoremstyle{definition}
\newtheorem{example}{Example}[section]

\renewcommand{\ttdefault}{lmtt} % set Latin Modern tt as tt

% /uv command
\def\uv#1{\iflanguage{british}{``#1''}{\quotedblbase #1\textquotedblleft}}

%%% BEGIN listings settings %%%
\definecolor{bluekeywords}{rgb}{.13, .13, 1}
\definecolor{greencomments}{rgb}{0, .5, 0}
\definecolor{redstrings}{rgb}{.9, 0, 0}
\definecolor{gray}{rgb}{.4, .4, .4}

\lstset{
    basicstyle=\ttfamily,
    backgroundcolor=\color{yellow!10},
    columns=fullflexible,
    showstringspaces=false,
    commentstyle=\color{gray}\upshape,
    captionpos=b,
    tabsize=4,
    keepspaces=true,
    belowskip=-1.2 \baselineskip
}

\lstdefinestyle{c}{
    language=c,
    showspaces=false,
    showtabs=false,
    breaklines=true,
    showstringspaces=true,
    breakatwhitespace=true,
    escapeinside={<@}{@>},
    commentstyle=\color{greencomments},
    keywordstyle=\color{bluekeywords},
    stringstyle=\color{redstrings},
    basicstyle=\ttfamily,
    captionpos=b,
    numbers=left,
    xleftmargin=1.5em,
    frame=trBL
}
%%% END listings settings %%%


%===============================================================================
% REVIEW vs. FINAL VERSION
%===============================================================================
\ExcelFinalCopy


%===============================================================================
% PDF CUSTOMISATION
%===============================================================================
\hypersetup{%
    pdftitle={Advanced Static Analysis of Atomicity in Concurrent Programs through Facebook Infer},
    pdfauthor={Dominik Harmim <xharmi00@stud.fit.vutbr.cz>},
    pdfsubject={Excel@FIT 2021 Paper},
    pdfkeywords={Facebook Infer, Static Analysis, Abstract Interpretation, Atomicity Violation, Contracts for Concurrency, Concurrent Programs, Program Analysis, Atomicity, Atomer, Incremental Analysis, Modular Analysis, Compositional Analysis, Interprocedural Analysis}%
}


%===============================================================================
% ARTICLE INFORMATION
%===============================================================================
\ExcelYear{2021}

\PaperTitle{Advanced Static Analysis of Atomicity in Concurrent Programs through Facebook Infer}

\Authors{Dominik Harmim*}
\affiliation{%
    *\href{mailto:xharmi00@stud.fit.vutbr.cz}{xharmi00@stud.fit.vutbr.cz},
    \textit{Faculty of Information Technology, Brno University of Technology}%
}

\Keywords{Facebook Infer\,---\,Static Analysis\,---\,Abstract Interpretation\,---\,Atomicity Violation\,---\,Contracts for Concurrency\,---\,Concurrent Programs\,---\,Program Analysis\,---\,Atomicity\,---\,Atomer\,---\,Incremental Analysis\,---\,Modular Analysis\,---\,Compositional Analysis\,---\,Interprocedural Analysis}

\Supplementary{%
    \href{https://github.com/harmim/infer}{Atomer Repository}%
    \,---\,\href{https://github.com/harmim/infer/wiki}{Atomer Wiki}%
    \,---\,\href{https://github.com/facebook/infer}{Facebook Infer Repository}%
}


%===============================================================================
% ABSTRACT and TEASER
%===============================================================================
\Abstract{%
    This work aims to improve and extend \emph{Atomer}. A~further goal is to perform new experiments with it. Atomer is a~\emph{static analyser} that detects \emph{atomicity violations}, created within the bachelor’s thesis of the author as a~module of \emph{Facebook Infer}\,---\,an open-source static analysis framework that promotes efficient analysis. The original analysis assumes that \emph{sequences of function calls} executed \emph{atomically once} should probably be executed \emph{always atomically}, and it naturally works with sequences. In this work, to improve \emph{scalability}, the use of sequences was \emph{approximated by sets}. Further, several new features were implemented, notably: support for \emph{C++ and Java languages}; more advanced and precise \emph{manipulation with locks}; and the analysis's \emph{parametrisation}. The new extensions were verified and evaluated on programs created for testing purposes. Furthermore, new experiments on \emph{extensive real-life programs} were made, and already fixed and reported \emph{real bugs} were rediscovered. The experiments revealed a~\emph{significant increase of precision} of the new version of Atomer.%
}

\Teaser{\TeaserImage{teaser.pdf}}


%===============================================================================
\begin{document}


% spacing around math mode
\setlength{\abovedisplayskip}{.3em}
\setlength{\belowdisplayskip}{.3em}


\startdocument


%===============================================================================
% ARTICLE CONTENTS
%===============================================================================


%===============================================================================
\section{Introduction}

Bugs are an integral part of computer programs ever since the inception of the programming discipline. Unfortunately, they are often hidden in unexpected places, and they can lead to unexpected behaviour, which may cause significant damage. Nowadays, developers have many possibilities of catching bugs in the early development process. \emph{Dynamic analysers} or tools for \emph{automated testing} are often used, and they are satisfactory in many cases. Nevertheless, they can still leave too many bugs undetected because they can analyse only \emph{particular program flows} dependent on the input data. An alternative solution is \emph{static analysis} that has its shortcomings as well, such as the \emph{scalability} on large codebases or a~considerably high rate of incorrectly reported errors (so-called \emph{false positives} or \emph{false alarms}). Several efficient tools for static analysis were implemented, e.g., Coverity or CodeSonar. However, they are often proprietary and difficult to openly evaluate and extend.

Recently, Facebook introduced \emph{Facebook Infer}: an \emph{open-source} tool for creating \emph{highly scalable}, \emph{compositional}, \emph{incremental}, and \emph{interprocedural} static analysers. Facebook Infer has grown considerably, but it is still under active development by many teams across the globe. It is employed every day not only in Facebook itself, but also in other companies, such as Spotify, Uber, Mozilla, or Amazon. Currently, Facebook Infer provides several analysers that check for various types of bugs, such as buffer overflows, data races and some forms of deadlocks and starvation, null-dereferencing, or memory leaks. However, most importantly, Facebook Infer is a~\emph{framework} for building new analysers quickly and easily. Unfortunately, the current version of Facebook Infer still lacks better support for \emph{concurrency bugs}. While it provides a~reasonably advanced data race analyser, it is limited to Java and C++ programs only and fails for C~programs, which use a~\emph{lower-level lock manipulation}.

In \emph{concurrent programs}, there are often \emph{atomicity requirements} for the execution of specific sequences of instructions. Violating these requirements may cause many kinds of problems, such as unexpected behaviour, exceptions, segmentation faults, or other failures. \emph{Atomicity violations} are usually not verified by compilers, unlike syntactic or some sorts of semantic rules. Moreover, atomicity requirements, in most cases, are not even documented at all. Therefore, in the end, programmers themselves must abide by these requirements and usually lack any tool support. Furthermore, in general, it is difficult to avoid errors in \emph{atomicity-dependent programs}, especially in large projects, and even more laborious and time-consuming is finding and fixing them.

Within the author's bachelor's thesis~\cite{harmimBP}, \emph{Atomer}\footnote{The implementation of~\textbf{Atomer} is available on GitHub as an \emph{open-source} repository. The link can be found among the supplementary materials of this paper.} was proposed\,---\,a~\emph{static analyser} for finding some forms of \emph{atomicity violations} implemented as a~Facebook Infer's module. In particular, the stress is put on the \emph{atomic execution of sequences of function calls}, which is often required, e.g., when using specific library calls. It is based on the assumption that sequences of function calls executed \emph{atomically once} should probably be executed \emph{always atomically}, and it naturally works with sequences. In fact, the idea of checking the atomicity of certain sequences of function calls is inspired by the work of \emph{contracts for concurrency}~\cite{contracts2017}. In the terminology of~\cite{contracts2017}, the atomicity of specific sequences of calls is the most straightforward (yet very useful in practice) kind of contracts for concurrency. The implementation of the first version of Atomer mainly targets \emph{C~programs} that use \emph{POSIX thread}, i.e., \emph{PThread locks}.

Within this work, Atomer was improved and extended. Further, other experiments were performed. In particular, to improve \emph{scalability}, working with sequences of function calls was \emph{approximated} by working with \emph{sets of function calls}. Furthermore, several new features were implemented, notably: support for \emph{C++ and Java languages}; more advanced and precise \emph{manipulation with locks}; and the analysis's \emph{parametrisation}.

The development of Atomer and its extensions have been discussed with the developers of Facebook Infer, and it was supported under the H2020 ECSEL project Aquas. Currently, it is a~part of the H2020 ECSEL project Arrowhead Tools. Parts of the paper are taken from the thesis~\cite{harmimBP}.

The rest of the article is organised as follows. In Section~\ref{sec:infer}, there is introduced the \emph{Facebook Infer} framework. \emph{Atomer} is described in Section~\ref{sec:atomer}. This is followed by Section~\ref{sec:proposal}, which considers all the extensions and improvements proposed within this work. The implementation of these extensions, together with the experimental evaluation of the new Atomer's features and other experiments performed within this work, are discussed in Section~\ref{sec:exp}. Finally, the paper is concluded in Section~\ref{sec:conc}.


%===============================================================================
\section{Facebook Infer}
\label{sec:infer}

This section describes the principles and features of \emph{Facebook Infer}. The description is based on information provided at the Facebook Infer's website\footnote{\textbf{Facebook Infer's} website: \url{https://fbinfer.com}.} and in~\cite{inferAISpeech}. Parts of this section are taken from~\cite{harmimBP}.

Facebook Infer is an \emph{open-source}\footnote{A~link to the \textbf{Facebook Infer's open-source repository} is in the supplementary materials of the paper.} \emph{static analysis framework}\footnote{A~brief explanation of \textbf{static analysis} itself can be found in~\cite{harmimBP}\,---\,Section~2.1. In more detail, it is then explained in~\cite{staticAnalysisMoller, programAnalysisNielson, staticAnalysisRival}.}, which can discover various kinds of software bugs of a~given program, emphasising \emph{scalability}. A~more detailed explanation of Facebook Infer architecture is given in Section~\ref{sec:fbinferArch}. Facebook Infer is implemented in \emph{OCaml}\footnote{\textbf{OCaml's} website: \url{https://ocaml.org}.}\,---\,a~\emph{functional} programming language, also supporting \emph{imperative} and \emph{object-oriented} paradigms. Facebook Infer was originally a~standalone tool focused on \emph{sound verification} of the absence of \emph{memory safety violations}, which was first published in the well-known paper~\cite{inferBiabduction}.

Facebook Infer can analyse programs written in several languages. In particular, it supports the following languages: C, C++, Java, and Objective-C (and C\#, see~\cite{inferCSharp}). Moreover, it is possible to extend Facebook Infer's \emph{frontend} for supporting other languages. Currently, Facebook Infer contains many analyses focusing on various kinds of bugs, e.g., \emph{Inferbo} (buffer overruns); \emph{RacerD} (data races)~\cite{racerD, staticRaceDetectorTruePositives}; and other analyses that check for buffer overflows, some forms of deadlocks and starvation, null-dereferencing, memory leaks, resource leaks, etc.

\subsection{Abstract Interpretation in Facebook Infer}

Facebook Infer is a~general framework for static analysis of programs, and it is based on \emph{abstract interpretation}\footnote{\textbf{Abstract interpretation} is explained and formally defined in~\cite{harmimBP}\,---\,Section~2.1.1. Additional description can be found in~\cite{AILatticeModelCousot, wideningNarrowingCousot, programAnalysisNielson, staticAnalysisRival, staticAnalysisMoller}.}. Despite the original approach taken from~\cite{inferBiabduction}, Facebook Infer aims to find bugs rather than \emph{formal verification}. It can be used to develop new sorts of \emph{compositional} and \emph{incremental} analysers quickly (\emph{intraprocedural} or \emph{interprocedural}~\cite{programAnalysisNielson}) based on the concept of function \emph{summaries}. In general, a~\emph{summary} represents \emph{preconditions} and \emph{postconditions} of a~function~\cite{hoare}. However, in practice, a~summary is a~custom data structure that may be used for storing any information resulting from the analysis of particular functions. Facebook Infer generally does not compute the summaries during the analysis along the \emph{Control Flow Graph} (\textbf{CFG}~\cite{controlFlowAnalysisAllen}) as it is done in classical analyses based on the concepts from~\cite{DFAGraphReach, DFAApproaches}. Instead, Facebook Infer performs the analysis of a~program \emph{function-by-function along the call tree}, starting from its leaves (demonstrated in Example~\ref{ex:inferAnalysis}). Therefore, a~function is analysed, and a~summary is computed without knowledge of the call context. Then, the summary of a~function is used at all of its call sites. Since the summaries do not differ for different contexts, the analysis becomes more scalable, but it can lead to a~loss of accuracy.

In order to create a~new intraprocedural analyser in Facebook Infer, it is needed to define the following (the listed items are described in more detail in~\cite{harmimBP}\,---\,Section~2.1.1):
\vspace{-.5em}
\begin{enumerate}
    \item The \emph{abstract domain}~$ \boldsymbol{Q} $, i.e., a~type of an \emph{abstract state}.

    \item The \emph{ordering operator}~$ \sqsubseteq $, i.e., an ordering of abstract states.

    \item The \emph{join} operator~$ \sqcup $, i.e., the way of joining two abstract states.

    \item The \emph{widening} operator~$ \triangledown $, i.e., the way how to enforce the termination of the computation.

    \item The \emph{Transfer functions}~$ \tau $, i.e., a~transformer that takes an abstract state as an input and produces an abstract state as an output.
\end{enumerate}
\vspace{-.5em}
Further, to create an interprocedural analyser, it is required to define additionally:
\begin{enumerate*}[label={(\roman*)}]
    \item A~type of function summaries~$ \chi $.

    \item The logic for using summaries in transfer functions and the logic for transforming an intraprocedural abstract state to a~summary.
\end{enumerate*}
\vspace{-.5em}

An important feature of Facebook Infer improving its scalability is the \emph{incrementality} of the analysis. It allows one to analyse separate code changes only, instead of analysing the whole codebase. It is more suitable for extensive and variable projects where ordinary analysis is not feasible. The incrementality is based on \emph{reusing summaries} of functions for which there is no change in them neither in the functions transitively invoked from them, as shown in Example~\ref{ex:inferAnalysis}.

\subsection{Architecture of the Infer AI}
\label{sec:fbinferArch}

The architecture of the abstract interpretation framework of Facebook Infer (\textbf{Infer AI}) may be split into three major parts, as demonstrated in Figure~\ref{fig:inferArch}: a~\emph{frontend}, an \emph{analysis scheduler} (and a~\emph{results database}), and a~set of \emph{analyser plugins}.

\begin{figure}[hbt]
    \centering
    \includegraphics[width=.8 \linewidth]{infer-architecture.pdf}
    \caption{The architecture of Facebook Infer's abstract interpretation framework~\cite{harmimBP}}
    \label{fig:inferArch}
\end{figure}

The frontend compiles input programs into the \emph{Smallfoot Intermediate Language} (SIL) and represents them as a~CFG. There is a~separate CFG representation for each analysed function. Nodes of this CFG are formed as SIL instructions (the individual instructions are outlined in~\cite{harmimBP}). The frontend allows one to propose \emph{language-independent} analyses (to a~certain extent) because it supports input programs to be written in multiple languages.

The next part of the architecture is the scheduler, which defines the order of the analysis of single functions according to the appropriate \emph{call graph}\footnote{\textbf{A~call graph} is a~\emph{directed graph} describing call dependencies among functions.}. The scheduler also checks if it is possible to simultaneously analyse some functions, allowing Facebook Infer to run the analysis in parallel.

\begin{example}
    \label{ex:inferAnalysis}
\end{example}
\vspace{-.49em}
\noindent
For demonstrating the order of the analysis in Facebook Infer and its incrementality, assume a~call graph given in Figure~\ref{fig:inferCallGraph}. At first, leaf functions \texttt{F5} and \texttt{F6} are analysed. Further, the analysis goes on towards the root of the call graph\,---\,\texttt{F\textsubscript{MAIN}}, while considering the dependencies denoted by the edges. This order
\begin{wrapfigure}{r}{.42 \linewidth}
    \centering
    \vspace{-1em}
    \includegraphics[width=.2 \textwidth]{infer-call-graph.pdf}
    \captionof{figure}{A~call graph for an illustration of Facebook Infer's analysis process~\cite{harmimBP}}
    \label{fig:inferCallGraph}
\end{wrapfigure}
ensures that a~summary is available once a~nested function call is abstractly interpreted within the analysis. When there is a~subsequent code change, only directly changed functions and all the functions up the call path are re-analysed. For instance, if there is a~change of source code of function \texttt{F4}, Facebook Infer triggers reanalysis of functions \texttt{F4}, \texttt{F2}, and \texttt{F\textsubscript{MAIN}} only.

The last part of the architecture consists of a~set of analyser plugins. Each plugin performs some analysis by interpreting SIL instructions. The result of the analysis of each function (function summary) is stored in the results database. The interpretation of SIL instructions (\emph{commands}) is made using the \emph{abstract interpreter} (also called the \emph{control interpreter}) and \emph{transfer functions} (also called the \emph{command interpreter}). The transfer functions take a~previously generated \emph{abstract state} of an analysed function as an input, and by applying the interpreting command, produce a~new abstract state. The abstract interpreter interprets the command in an \emph{abstract domain} according to the CFG. This workflow is shown in a~simplified form in Figure~\ref{fig:inferAnalysis}.

\begin{figure}[hbt]
    \centering
    \includegraphics[width=.8 \linewidth]{infer-analysis.pdf}
    \caption{Facebook Infer's abstract interpretation process~\cite{harmimBP}}
    \label{fig:inferAnalysis}
\end{figure}


%===============================================================================
\section{\hspace{-.15em}Atomer: Atomicity Violations Detector}
\label{sec:atomer}

This section introduces the principles of the \emph{static analyser Atomer} proposed as a~module of \emph{Facebook Infer} for finding some forms of \emph{atomicity violations}. Atomer was proposed and in detail described in the bachelor's thesis of the author of this paper~\cite{harmimBP}. Therefore, naturally, the following description is based on the mentioned thesis.

Atomer concentrates on checking the \emph{atomicity of the execution of certain sequences of function calls}, which is often required for \emph{concurrent programs'} correct behaviour. Atomer's principle is based on the assumption that sequences of function calls executed \emph{atomically once} should probably be executed \emph{always atomically}.

The proposal of Atomer is based on \emph{basic contracts for concurrency}~\cite{harmimBP, contracts2017}. These allow one to define \emph{sequences of functions} required to be \emph{executed atomically}. Atomer can automatically derive candidates for such contracts and then verify whether the contracts are fulfilled. Both of these steps are done statically. The proposed analysis is divided into two parts (\emph{phases of the analysis}):
\vspace{-.5em}
\begin{enumerate}[label={\textbf{Phase~\arabic*}:}, leftmargin=4.2em]
    \item Detection of (likely) \emph{atomic sequences}.

    \item Detection of \emph{atomicity violations} (violations of the atomic sequences).
\end{enumerate}
\vspace{-.5em}
The phases are in depth described in the sections below. Moreover, these phases of the analysis and its workflow are illustrated in Figure~\ref{fig:atomerPhasesSequences}.

\begin{figure}[hbt]
    \centering
    \includegraphics[width=.8 \linewidth]{analyser-proposal.pdf}
    \caption{\emph{Phases} of the Atomer's analysis and the analysis \emph{high-level process} illustration}
    \label{fig:atomerPhasesSequences}
\end{figure}

This section describes the proposal of Atomer in general. The concrete types of the \emph{abstract states} (i.e., elements of the \emph{abstract domain}~$ \boldsymbol{Q} $) and the \emph{summaries}~$ \chi $, along with the implementation of all necessary \emph{abstract interpretation operators}, are stated in~\cite{harmimBP}. However, actually, the abstract states~$ s \in \boldsymbol{Q} $ of both phases of the analysis are proposed as \emph{sets}. So, in fact, the \emph{ordering operator}~$ \sqsubseteq $ is implemented using testing for a~\emph{subset} (i.e., $ s \sqsubseteq s^\prime \Leftrightarrow s \subseteq s^\prime $, where $ s, s^\prime \in \boldsymbol{Q} $), the \emph{join operator}~$ \sqcup $ is implemented as the \emph{set union} (i.e., $ s \sqcup s^\prime \Leftrightarrow s \cup s^\prime $), and the \emph{widening operator}~$ \triangledown $ is implemented using the join operator (i.e., $ s \triangledown s^\prime \Leftrightarrow s \sqcup s^\prime $).

\subsection{Phase~1: Detection of Atomic Sequences}

\textbf{Phase~1} of Atomer detects \emph{sequences of functions} that should be \emph{executed atomically}. Intuitively, the detection is based on looking for sequences of functions executed atomically on some path through a~program.

The detection of sequences of calls to be executed atomically is based on analysing all paths through the CFG of a~function and generating all pairs $ {(A, B)} \in {\Sigma^* \times \Sigma^*} $ (where~$ \Sigma^* $ is a~set of all possible sequences of functions from~$ \Sigma $ in a~given program) of \emph{reduced sequences}~\cite{harmimBP} of function calls for each path such that: Here, $ A $ is a~reduced sequence of function calls that appear between the beginning of the function being analysed and the first lock; between an unlock and a~subsequent lock; or between an unlock and the end of the function being analysed. $ B $ is a~reduced sequence of function calls that follow the calls from~$ A $ and that appear between a~lock and an unlock (or between a~lock and the end of the function being analysed). Thus, the \emph{abstract state} $ s \in \boldsymbol{Q} $ is defined as $ 2^{2^{\Sigma^* \times \Sigma^*}} $ (because there is a~set of the ${ (A, B) }$ pairs for each program path).

The \emph{summary}~$ \chi_\mathtt{f} \in 2^{\Sigma^*} \times \Sigma^* $ of a~function~\texttt{f} is then defined as $ \chi_\mathtt{f} = (\boldsymbol{B}, AB) $, where:
\vspace{-.5em}
\begin{itemize}
    \item $ \boldsymbol{B} $ is a~set constructed that contains all the~$ B $ sequences that appear on program paths through~\texttt{f}. In other words, this component of the summary is a~set of sequences of atomic function calls appearing in an analysed function.

    \item $ AB $ is a~\emph{concatenation} of all the~$ A $ and~$ B $ sequences with removed duplicates of function calls. In particular, assume that there is the following computed set of ${ (A, B) }$ pairs: $ \{{(A_1, B_1)}, \allowbreak {(A_2, B_2)}, \ldots, {(A_n, B_n)}\} $, then the result is concatenated sequence $ A_1 \cdot B_1 \cdot A_2 \cdot B_2 \cdot \ldots \cdot A_n \cdot B_n $ with removed duplicates. Intuitively, in this component of the summary, it is gathered occurrences of all called functions within an analysed function obtained by concatenation of all the~$ A $ and~$ B $ sequences. $ AB $ is recorded to analyse functions higher in the \emph{call hierarchy} since locks/unlocks can appear in such a~\emph{higher-level} function.
\end{itemize}
\vspace{-1em}

\begin{example}
    For instance, the analysis of the function~\texttt{f} from Listing~\ref{list:atomerPhase1} produces the following sequences:
    $$
        \overbrace{\text{\texttt{x,~\sout{x},~y}}}^A~\overbrace{\text{\texttt{[a,~b,~\sout{b}]}}}^B
    $$
    The strikethrough of the functions~\texttt{x} and~\texttt{b} denotes removing already recorded function calls in the~$ A $ and~$ B $ sequences. For the above, the abstract state at the end of an interpretation of the function~\texttt{f} is $ s_\mathtt{f} = \{\{((\mathtt{x, y}), (\mathtt{a, b})), (\varepsilon, \varepsilon)\}\} $. The derived summary~$ \chi_\mathtt{f} $ for the function~\texttt{f} is $ \chi_\mathtt{f} = {(\{{(\mathtt{a, b})}\}, {(\mathtt{x, y, a, b})})} $.
\end{example}

\begin{lstlisting}[
    style=c, label={list:atomerPhase1}, float=hbt,
    caption={A~code snippet used for an illustration of the derivation of \emph{sequences of functions called atomically}}
]
void f() {
    x(); x(); y();
    <@\textcolor{red}{lock}@>(&L); // (a, b)
    a(); b(); b();
    <@\textcolor{red}{unlock}@>(&L);
}
\end{lstlisting}

The derived sequences of calls assumed to execute atomically\,---\,the~$ \boldsymbol{B} $ sequences\,---\,from the summaries of all analysed functions are stored into a~file used during \textbf{Phase~2}, which is described below.

\subsection{\hspace{-.35em}Phase~2: Detection of Atomicity Violations}

In the second phase of the analysis, i.e., when \emph{detecting violations} of the atomic sequences obtained from \textbf{Phase~1}, the analysis looks for \emph{pairs of functions} that \emph{should be called atomically} (or just for single functions if there is only one function call in an atomic sequence) while this is not the case on some path through the CFG. The pairs of function calls to be checked for atomicity are obtained as follows: For each function~\texttt{f} with the \emph{summary}~$ \chi_\mathtt{f} = {(\boldsymbol{B}, AB)} $ in a~given program, it is taken the first component~$ \boldsymbol{B} $ of the summary~$ \chi_\mathtt{f} $, i.e., $ \boldsymbol{B} = {\{B_1, B_2, \ldots, B_n\}} $, and it is taken \emph{every pair} $ {(\mathtt{x}, \mathtt{y})} \in \Sigma \times \Sigma $ of functions that appear as a~\emph{substring} in some of the~$ B_i $ sequences, i.e., $ B_i = w \cdot \mathtt{x} \cdot \mathtt{y} \cdot w^\prime $ for some sequences~$ w, w^\prime $. Note that~\texttt{x} could be~$ \varepsilon $ (an empty sequence) if some~$ B_i $ consists of a~single function. All these \uv{atomic pairs} are put into the set $ \Omega \in 2^{\Sigma \times \Sigma} $.

An element of this phase's \emph{abstract state} is a~triple $ {(\mathtt{x}, \mathtt{y}, \Delta)} \in \Sigma \times \Sigma \times 2^{\Sigma \times \Sigma} $, where $ {(\mathtt{x}, \mathtt{y})} $ is a~pair of the most recent function calls, and~$ \Delta $ is a~\emph{set of pairs that violate atomicity}. Thus, the abstract state $ s \in \boldsymbol{Q} $ is defined as $ 2^{\Sigma \times \Sigma \times 2^{\Sigma \times \Sigma}} $. Whenever a~function~\texttt{f} is called, it is created a~new pair ${ (\mathtt{x}^\prime, \mathtt{y}^\prime) }$ of the most recent function calls from the previous pair ${ (\mathtt{x}, \mathtt{y}) }$ (i.e., $ {(\mathtt{x}^\prime, \mathtt{y}^\prime)} = {(\mathtt{y}, \mathtt{f})} $). Further, when the current program state is not inside an \emph{atomic block}, it is checked whether the new pair (or just the last call) violates the atomicity (i.e., $ {(\mathtt{x}^\prime, \mathtt{y}^\prime)} \in \Omega \vee {(\varepsilon, \mathtt{y}^\prime)} \in \Omega $). When it does, it is added to the set~$ \Delta $ of pairs that violate atomicity.

\begin{example}
    \sloppy
    To demonstrate the detection of an atomicity violation, assume the functions~\texttt{f} and~\texttt{g} from Listing~\ref{list:atomerPhase2}. The set of atomic sequences of the function~\texttt{f} with the summary~$ \chi_\mathtt{f} = (\boldsymbol{B}, AB) $ is $ \boldsymbol{B} = \{(\mathtt{a, b, c})\} $, thus $ \Omega = \{{(\mathtt{a, b})}, {(\mathtt{b, c})}\} $. In the function~\texttt{g}, an atomicity violation is detected because the pair of functions~\texttt{b} and~\texttt{c} is not called atomically.
\end{example}

\begin{lstlisting}[
    style=c, label={list:atomerPhase2}, float=hbt,
    caption={Example of an \emph{atomicity violation}}
]
void f() {
    <@\textcolor{red}{lock}@>(&L); // (a, b, c)
    a(); b(); c();
    <@\textcolor{red}{unlock}@>(&L);
}
void g() {
    // <@\textcolor{red}{ATOMICITY\_VIOLATION:}@> (b, c)
    x(); b(); c(); y();
}
\end{lstlisting}

The sets of atomicity violations~$ \Delta $ from individual functions are the final reported atomicity violations seen by a~user.


%===============================================================================
\section{\hspace{-.15em}Proposal of Enhancements for Atomer}
\label{sec:proposal}

Atomer was implemented in~\cite{harmimBP} according to the proposal discussed in the previous section. The analyser is working as expected. Moreover, it can be used in practice to analyse various kinds of programs, and it may find \emph{real atomicity related bugs}. Nevertheless, there are still several limitations and cases where Atomer would not work correctly, i.e., cases not considered during the original proposal. Below, there are proposed solutions for some of the limitations. The solutions enhance the analysis's \emph{precision} and \emph{scalability}. Furthermore, Section~\ref{sec:exp} provides an overview of the implementation of a~new version of Atomer.

\subsection{Approx. of the Use of Sequences by Sets}

Regarding \emph{scalability}, Atomer can have problems with more \emph{extensive} and \emph{complex} programs (problems with \emph{memory} as well as problems with \emph{analysis time}). The problem is working with the sets of ${ (A, B) }$ pairs of \emph{sequences} of function calls in \emph{abstract states} (during \textbf{Phase~1}). It may be necessary to store many of these sequences, and they could be very long (due to all different paths through the CFG of an analysed program). It seems promising to \emph{approximate} it (\emph{abstraction refinement}) by working with the sets of ${ (A, B) }$ pairs of \textbf{sets} of function calls. Elements of these pairs are also occurring in the the first phase's \emph{summaries}, and they are used during \textbf{Phase~2}. Thus, it is needed to make a~certain approximation in these structures and algorithms likewise.

In particular, this proposed solution is more scalable because the order of stored function calls is not relevant anymore while working with sets. Therefore, less memory is required because the same sets of function calls are not stored multiple times. The analysis is also faster since there are stored fewer sets of function calls to work with. On the other hand, the analysis is less accurate because the new approach causes some loss of information. In practice, this loss of information could eventually lead to \emph{false alarms}. However, the number of such false alarms should not often be so significant.

The \emph{detection of sequences of calls to be executed atomically} now generates all ${ (A, B) }$ pairs of \emph{sets} of function calls for each path instead of pairs of sequences. I.e., $ {(A, B)} \in 2^\Sigma \times 2^\Sigma $. The semantics of the pairs is preserved. So, the \emph{abstract state} $ s \in \boldsymbol{Q} $ is redefined as $ 2^{2^{2^\Sigma \times 2^\Sigma}} $. In all the implemented algorithms and definitions, it is sufficient to work with:
\begin{enumerate*}[label={(\roman*)}]
    \item \emph{sets}~$ 2^\Sigma $ of functions, instead of \emph{sequences}~$ \Sigma^* $ of functions;

    \item \emph{empty sets}~$ \emptyset $, instead of \emph{empty sequences}~$ \varepsilon $;
    
    \item and a~\emph{union}~$ \cup $ of sets, instead of a~\emph{concatenation}~$ \cdot $ of sequences.
\end{enumerate*}
Consequently, also the summary is redefined as $ \chi \in 2^{2^\Sigma} \times 2^\Sigma $.

\begin{example}
    For demonstrating the approximation of the analysis to sets, assume functions~\texttt{f} and~\texttt{g} from Listing~\ref{list:atomerPhase1Sets}. After the approximation, the produced abstract states and summaries are as follows (i.e., they are the same for both functions because there are the same locked/unlocked function calls, only the order of calls differs): $ s_\mathtt{f} = s_\mathtt{g} = \{\{({\{\mathtt{a}, \mathtt{b}\}}, {\{\mathtt{x}, \mathtt{y}\}}), {(\emptyset, \emptyset)}\}\} $, $ \chi_\mathtt{f} = \chi_\mathtt{g} = ({\{\{\mathtt{x}, \mathtt{y}\}\}}, {\{\mathtt{a}, \mathtt{b}, \mathtt{x}, \mathtt{y}\}}) $.
\end{example}

\begin{lstlisting}[
    style=c, label={list:atomerPhase1Sets}, float=hbt,
    caption={A~code snippet used to illustrate the Atomer's \textbf{Phase~1} \emph{approximation} of the analysis with \emph{sets of function calls}}
]
void f() {
    a(); b();
    <@\textcolor{red}{lock}@>(&L); // (x, y) -> {x, y}
    x(); y();
    <@\textcolor{red}{unlock}@>(&L);
}
void g() {
    b(); a();
    <@\textcolor{red}{lock}@>(&L); // (y, x) -> {x, y}
    y(); x();
    <@\textcolor{red}{unlock}@>(&L);
}
\end{lstlisting}

\emph{Detecting violations of atomicity} works almost the same way as before the approximation. There is only one difference. Before, it was detected violations of atomic sequences obtained from \textbf{Phase~1}. Now, \textbf{atomic sets} are obtained; hence, the detection of violations of atomic sets is performed. It is needed to propose a~new algorithm that derives pairs of function calls (from the atomic sets) to be checked for atomicity. To obtain the pairs, it is taken a~union of sets containing all \emph{2-element variations} of single atomic sets (i.e., all possible pairs).

\begin{example}
    \sloppy
    For example, assume that in \textbf{Phase~1}, there was analysed a~function~\texttt{f}, which produced the summary $ \chi_f = {(\boldsymbol{B}, AB)} $. Assume that a~set of sets of functions that should be called atomically is the following: $ \boldsymbol{B} = \{{\{\mathtt{a}, \mathtt{b}, \mathtt{c}\}}\} $, the analysis now looks for the following pairs of functions that are not called atomically (all 2-element variations): $ \Omega = \{{(\mathtt{a}, \mathtt{b})}, {(\mathtt{a}, \mathtt{c})}, {(\mathtt{b}, \mathtt{a})}, {(\mathtt{b}, \mathtt{c})}, {(\mathtt{c}, \mathtt{a})}, {(\mathtt{c}, \mathtt{b})}\} $.
\end{example}


\subsection{Advanced Manipulation with Locks}

\todo{TODO}

\subsection{Analysis's Parametrisation}

One of the main reasons that Atomer reports \emph{false alarms} is that in \emph{critical sections}, in practice, there are sometimes called \emph{generic functions} that do not influence atomicity violations (such as functions for printing to the standard output, functions for recasting variables to different types, functions related to iterators, and whatever other \uv{safe} functions for particular program types). Often, to find some atomicity violations, it is sufficient to focus only on certain \uv{critical} functions. In general, usually, calls of \emph{constructor} and \emph{destructor} methods of classes do no effect atomicity violations. Therefore, these calls could be implicitly ignored. Nonetheless, it can be demanding to identify the functions that should be set aside or the functions to focus on because it is application-specific. Although, a~user may provide this information to the analysis. For this reason, the following input parameters of the analysis are proposed:
\begin{enumerate*}[label={(\roman*)}]
    \item a~list of functions that will not be analysed;
    
    \item a~list of functions that will be analysed (and all other functions will not be);
    
    \item a~list of functions whose calls will not be considered;
    
    \item a~list of functions whose calls will be considered (and all other function calls will not be).
\end{enumerate*}
It is possible to combine these parameters, and they can be enabled for individual phases of the analysis. The parameters are proposed to be file names of readable text files containing one function name per line. Moreover, suppose the line starts with character \texttt{R} followed by a~whitespace. In that case, the function name is considered a~\emph{regular expression} so that several function names could be taken into account at once.

\todo{TODO}


%===============================================================================
\section{Implementation and Experiments}
\label{sec:exp}

\todo{TODO}


%===============================================================================
\section{Conclusions}
\label{sec:conc}

\todo{TODO}


\section*{Acknowledgements}
I~thank my colleagues from VeriFIT for their assistance. I~would particularly like to thank my supervisor Tomáš Vojnar. I~also wish to acknowledge Nikos Gorogiannis from the Infer team at Facebook for valuable discussions about the analyser’s development. Lastly, I~acknowledge the financial support received from the H2020 ECSEL project Aquas and H2020 ECSEL project Arrowhead Tools.


%===============================================================================
% REFERENCE LIST
%===============================================================================
\phantomsection
\bibliographystyle{unsrt}
\bibliography{2021-ExcelFIT-StaticAnalysisAtomicityInfer}


%===============================================================================
\end{document}


%===============================================================================
